{"pages":[],"posts":[{"title":"juc包之ReentrantLock","text":"jdk1.5之后新增了ReentrantLock类，可以在代码里更灵活的控制同步代码块，那么这一块是如何实现的呢？ 示例代码 ReentrantLock reentrantLock = new ReentrantLock(); reentrantLock.lock(); try { //something to do } catch (Exception e) { reentrantLock.unlock(); } 第一行初始化类对象 可以看到默认构造函数初始化的是一个非公平锁 还有一个重载的构造函数，通过传入布尔值，来控制初始化公平锁还是非公平锁，接下来先看非公平锁的实现第二行上锁 此处接着执行非公平锁的lock方法 首先执行compareAndSetState方法将state变量从0变成1，一开始state变量值默认为0，所以第一个执行lock方法的线程将会执行成功，然后执行setExclusiveOwnerThread方法，将当前线程对象赋值到exclusiveOwnerThread变量上，代表当前独占的线程。假如在之前已经有线程执行过lock方法了，已经修改过state变量值了，此时compareAndSetState方法就会执行失败，走下方acquire方法逻辑,acquire方法为从非公平锁父类AbstractQueuedSynchronizer继承而来的方法 首先执行tryAcquire方法，此处最终调用到了Sync类的nonfairTryAcquire方法 先获取当前执行的线程，再获取当前的state值。如果state值为0，代表在这期间占有锁的线程已经释放锁了，则跟lock方法一样，首先调用compareAndSetState方法修改state变量的值，修改成功则调用setExclusiveOwnerThread修改当前独占锁的线程对象，并返回true代表获取锁成功。如果state值不为0，但当前请求锁的线程就是当前锁的独占线程，即拥有锁的线程又一次请求了锁，则给state值加上请求的资源数，并判读state值是否溢出了，如果溢出则代表当前线程请求锁资源过多，则直接抛出错误（此处溢出得这个线程请求锁超过21亿次，挺难的）。没有溢出则去修改state值，并返回true。如果以上两种方式都不符合，则返回false，代表获取锁失败。（在这里的第一种判断是假设在执行后续逻辑前其他线程又释放了锁，则可以执行上锁并返回，第二种判断是为了实现锁的可重入，如果还是当前持有锁的线程在获取锁，则可以继续让它上锁） 再执行acquireQueued方法，在执行前先执行了addWaiter方法，并说明是独占节点。 先看addWaiter方法 先构造Node节点，传入当前线程对象，以及锁类型，此处为Exclusive独占然后将当前链表最后一个节点赋值给pred变量，如果pred变量不为null，则将node的前继节点设置为pred，并且将node设置成链表的最后一个节点，如果设置成功将之前链表的最后一个节点的后驱指向node，并返回node。(即是将node追加到链表的最后一个，并且将node赋值给代表链表最后一个节点的变量)如果pred变量为null，或者之前设置tail节点失败的话，则调用enq方法传入node节点，并返回node enq方法内部是个死循环，首先判断tail变量是否有值，如果无值则代表之前都还没有链表，则新建了一个node对象设置到head变量，代表是头节点，同时当下只有一个节点，则head也是tail。然后第二次循环时，tail变量将不再是null，此时执行上面的逻辑，将当前node设置成tail，并链接到上一个tail变量后形成链表。 再看acquireQueued方法 在死循环里，首先获取节点的前继，head节点由于在上面链表初始化的时候是单独new没有其他作用，所以此处判断前继是head节点时，即代表当前节点是第一个排队等待锁的，则调用tryAcquire方法去获取锁。如果获取成功的话，则将当前节点设置成head了，并返回false，代表不中断。如果获取锁失败的话，则调用shouldParkAfterFialedAcquire方法 会判断前继节点的waitStatus状态，首先判断是否是signal状态（该值为-1，node的初始值是0），接着判断是否大于0，也不满足，则走分支将前继节点的waitStatus修改为signal,并返回false，然后再第二次进入则由于已经改为了signal，则会返回true，然后走parkAndCheckInterrupt方法，该方法将调用LockSupport的park方法挂起当前线程等待其他线程唤醒，如果其他线程唤醒了这个线程，则获取当前线程是否已经被中断了（此处看下来感觉也就是挂起有用，判断中断没啥用，也跳不出循环，除非后续真的中断抛出错误了） 这里面的finally模块，感觉只有异常才会执行到cancelAcquire方法(__暂时不看了__） 在acquireQueued方法里如果获取到锁成功返回的话，即lock方法执行完毕不阻塞了，则会继续往下执行同步代码快逻辑。总结如下，调用lock方法首先去修改state变量的值，从0修改到1，修改成功即获取锁，并将当前线程对象设置给锁的独占线程变量上。然后如果修改失败了，则判断当前线程是不是独占锁的那个线程，如果是，则允许重入，即给当前线程放行，state变量继续往上加。如果以上都没成功的话，则将当前线程对象封装成一个node节点，放入锁的链表对象里，按照先入先出的规则（即不公平），遍历链表的node节点去获取锁，直到获取成功或者线程被中断 第三行释放锁 调用了父类AbstractQueuedSynchronizer继承而来的方法 先看tryRelease方法 计算当前state的值减去释放锁的数量，赋值给c变量，然后先判断当前线程是否是独占线程，不是则抛错。是的话判断c值是否是0，0代表当前线程已经不需要锁了，则设置独占线程变量为null，并设置free变量为true。然后将c变量值赋值给state变量，并返回free的值。 再回头看release方法如果tryRelease返回了false，则代表锁目前还有线程占有，则不做其他处理了如果返回了true，代表锁已经没有线程独占了，则获取head变量，并判断waitStatus状态是否不为0了（在lock时第一次获取不到锁时，会修改node的waitStatus为singal，值为-1），如果是，则调用unarkSuccessor方法 判断节点的waitStatus是否小于0，小于0则改为-1然后获取节点的下一个节点，之前lock方法挂起的就是下一个节点如果下一个节点为null或者waitStatus大于0（大于0只有canceled一种可能），则从tail往前遍历，直到遍历到一个waitStatus的值小于0的然后调用LockSupport的unpark方法去唤醒那个线程","link":"/2022/01/18/juc%E5%8C%85%E4%B9%8BReentrantLock/"},{"title":"rocketmq源码梳理之producer生产者","text":"rocketmq producer生产者的建立过程以及消息发送流程 示例代码 DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;); producer.start(); for (int i = 0; i &lt; 128; i++) try { { Message msg = new Message(&quot;TopicTest&quot;, &quot;TagA&quot;, &quot;OrderID188&quot;, &quot;Hello world&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(&quot;%s%n&quot;, sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); 代码的执行流程生产者对象的初始化DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;); 进入DefaultMqProducer类,发现类的成员变量在初始化的时候设置了不少默认值,整理如下: 变量名 变量类型 变量含义 默认值 retryResponseCodes Set 接受到set里包含的响应码后会进行重试 ResponseCode.TOPIC_NOT_EXIST, ResponseCode.SERVICE_NOT_AVAILABLE, ResponseCode.SYSTEM_ERROR, ResponseCode.NO_PERMISSION, ResponseCode.NO_BUYER_ID, ResponseCode.NOT_IN_CURRENT_UNIT createTopicKey String 自动会创建的topic名称 TBW102 defaultTopicQueueNums int topic默认的队列数 4 sendMsgTimeout long 发送消息的超时时间,默认单位毫秒 3000 compressMsgBodyOverHowmuch long 超过该值配置大小,消息会进行压缩,单位byte 4096 retryTimesWhenSendFailed int 发送失败后重试的次数 2 retryTimesWhenSendAsyncFailed int 异步发送失败后重试的次数 2 retryAnotherBrokerWhenNotStoreOK boolean 发送失败后是否切换到另一个节点发送 false maxMessageSize long 消息最大大小,单位byte 1024 * 1024 * 4 该类继承了ClientConfig类,该类初始化时也初始化了部分默认配置.并且在最终的构造方法中初始化了DefaultMQProducerImpl类,该类具体实现了生产者的一些逻辑 生产者的启动执行的DefaultMQProducerImpl类的start方法 先调用checkConfig方法检查必要配置是否配置再判断当前的消费者组名是否是CLIENT_INNER_PRODUCER,如果不是则更改当前生产者的instanceName,改为用pid+当前纳秒为名根据instanceName获取MqClientInstance对象,如果获取不到,则新建将当前生产者对象放入MqClientInstance的producerTable中,如果放入失败,则代表已经有重名的生产者组初始化过了,抛出错误,否则注册成功然后启动MqClientInstance对象,初始化完毕MqClientInstance对象是与服务端交互的主要对象,初始化流程与push消费者一致 生产者发送消息初始化生产者消息,指定了topic,tag,keys以及消息体其中topic指的是消息的主题,tags指定的消息用于筛选的字段,keys会根据相应规则将消息分配到不同的队列上然后调用producer.send(msg)将消息发送到服务端 此处获取了发送消息的超时时间,如果未设定,默认是3秒 send发送为同步发送,即发送时会阻塞等待发送结果 最终调用DefaultMQProducerImpl的sendDefaultImpl方法执行具体发送逻辑检查生产者状态,如果不在运行状态直接抛错检查消息是否合规获取当前时间作为消息的开始发送时间获取当前topic的发布信息,封装成了TopicPublishInfo对象,该对象可以获取topic的队列信息以及队列处于哪个broker下获取重试次数,如果是同步发送,则重试次数为1+retryTimesWhenSendFailed,如果不是同步发送,则为1次根据规则获取一个队列.默认规则是TopicPublishInfo里有个累加器,每次按顺序从messageQueueList中获取一个MessageQueue用于发送,如果之前发送失败,重试重新获取的,则按照累加器的值继续往下获取,直到获取到一个不是之前队列的进行发送 判断当前时间与上一次开始发送时间的差值是否超过了超时时间,超过了则直接跳出循环然后调用sendKernelImpl方法发送消息将当前时间作为发送完成时间更新延迟时间到FaultItem对象(暂不知道干啥用)根据通信方式,当前是同步,判断响应结果是否发送成功,如果不是且配置发送失败重试的话,则继续循环,如果发送成功,则直接返回发送结果. 接下来详细看下sendKernelImpl的方法 根据brokerName获取broker的地址,如果地址获取不到,则从服务端再根据topic拉取一次topic的发布信息,然后再获取一次brokerAddr如果brokerAddr不为null,判断是否使用虚拟通道发送消息,如果是,则将broker的端口号-2,如果不是,则对brokerAddr不做改变(暂不知道有啥用途)如果当前消息不是MessageBatch,则为消息生成一个唯一id判断消息是否超过配置的compressMsgBodyOverHowmuch大小,如果超过,则对消息体进行压缩,并修改对应标志位判断是否是事务消息,如果是,修改对应标志位调用checkForbiddenHook回调调用sendMessageHook的sendMessageBefor回调封装SendMessageRequestHeader对象发送给服务端 生成请求报文对象 在发送前再判断是否已经超过超时时间","link":"/2022/01/17/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8Bproducer%E7%94%9F%E4%BA%A7%E8%80%85/"},{"title":"rocketmq源码梳理之服务端的处理","text":"MqClientInstance维护了与服务端的连接,并且生产者和消费者都通过它与服务端进行交互,那么客户端请求的各个功能服务端那边是如何处理的呢? 客户端建立连接代码NettyRemotingClient类,与nameSrv通过netty建立连接NettyEncoder负责消息的编码NettyDecoder负责消息的解码IdleStateHandler负责空闲连接的处理NettyConnectManageHandler负责连接事件的回调处理NettyClientHandler负责对响应消息的处理 服务端监听连接代码NettyRemotingServer类,监听连接NettyEncoder负责消息的编码NettyDecoder负责消息的解码IdleStateHandler负责空闲连接的处理NettyConnectManageHandler负责连接事件的回调处理NettyServerHandler负责对响应消息的处理 一、从namesrv获取topic的路由信息客户端有一个定时器定期调用,由pollNameServerInterval控制调用周期,默认为30s,调用代码如下调用对象GetRouteInfoRequestHeader,只有一个成员变量topic 调用编码GET_ROUTEINFO_BY_TOPIC,值为105 客户端通过NettyEncoder生成报文并发送请求到namesrv,namesrv的NettyDecoder收到报文并解析,解析成功后由NettyServerHandler进行处理 此处收到的请求报文,所以执行processRequestCommand方法 由于namesrv只注册了defaultRequestProcessor,所以此处由defaultRequestProcessor进行处理,并且新建了一个Runnable对象,异步执行请求并且defaultRequestProcessor继承了AsyncNettyRequestProcessor类,所以执行这个分支代码. 并且defaultRequestProcessor的isRejectRquest方法固定返回false,所以不会进行流控然后将处理任务提交到线程池中进行处理,处理逻辑执行defaultRequestProcessor的processRequest方法 此处根据请求的编码走具体的处理分支,此处调用getRouteInfoByTopic方法 TopicRouteData对象里有四个成员变量 orderTopicConf (暂不知道什么作用)queueDatas topic的所有队列信息brokerDatas topic队列所属的所有broker信息filterServerTable (暂不知道有啥用) 根据topic从topicQueueTable中获取topic下的所有队列,然后遍历队列信息,获取到topic所在的brokerName,然后通过brokerName从brokerAddrTable中获取broker的信息.最后再遍历broker,通过brokerAddr从filterServerTable中获取filterServer的信息 从kvConfig中获取orderTopicConf的信息 这几个作用后面再去梳理 获取到信息后写回到客户端,此时是Response消息,所以客户端执行processResponseCommand方法根据请求的序列号获取到ResponseFuture对象,设置响应码,然后如果有回调函数则调用回调方法,没有就取消阻塞此处getRouteInfoByTopic是同步调用,调用完后调用waitResponse方法阻塞等待返回,要么等待超时时间后抛出异常,要么等待响应结果回来调用putResponse唤醒 最后获取到topicRouteData信息后,与本地之前的数据比较判断是否有更改,如果队列信息或者Broker信息有更改,则会去更新每一个生产者和消费者所持有的队列和broker信息 二、定期发送心跳到namesrvsendHeartbeatToAllBroker客户端有一个定时器定期调用,由heartbeatBrokerInterval控制调用周期,默认为30s,调用代码如下 首先调用prepareHeartbeatData方法生成心跳的信息数据HeartbeatData 心跳信息包括了当前客户端的id、客户端所有的消费者信息、客户端所有的生产者信息如果当前客户端没有任何的消费者和生产者,则直接返回,不用发送心跳 遍历下当前客户端交互的所有broker地址,进行遍历,如果当前客户端无消费者,且broker不是master(brokerId为0的是master),那也不用发送心跳,因为只能往master发送消息,slave只能消费消息然后调用sendHearbeat方法将心跳信息发送给broker,此处也是同步调用,超时时间取的mqClientApiTimeout,默认为3秒 requestCode为HEART_BEAT,值为34 然后通过传入的brokerAddr,与broker建立连接 这个方法可以看出,当addr为空时,就获取或者创建与namesrv的连接,而addr有值时,就获取或者建立与addr的连接然后就是broker端收到请求后的处理,borker端由ClientManageProcessor类负责心跳请求的处理 执行hearbeat方法首先根据心跳信息传过来的客户端消费者信息,判断当前broker是否有订阅组配置对象,如果有,则会调用createTopicInSendMessageBackMethod方法,以%retry%加上消费者组名,新建一个topicConfig对象(不知道创建topic干嘛),如果之前已经创建过则不做处理直接返回,如果没有创建过,则将TopicConfig对象放入topicConfigTable里,并且调用registerBrokerAll通知给所有broker,此处forceRegister默认传的true,代表一定会通知所有broker,如果该值是false的话,方法内部还会调用needRegister方法,请求Namesrv,请求编码是QUERY_DATA_VERSION,值是322(判断是否change,如果change也会去通知所有broker,此处如何判断的change,后续再看) 注册就是将当前broker信息封装成RegisterBrokerRequestHeader对象,请求编码是REGISTER_BROKER,值是103,然后去请求所有的Namesrv,将信息传过去,此处需要所有Namesrv全都请求结束才会接着往下执行 然后接着就是将消费者注册到当前broker 首先判断consumerTable中是否已经存在了,没有就放入.然后基于连接信息判断是否是最新的连接,判断订阅信息是否改变.如果连接是最新的(新加入了消费者)或者订阅信息改变了(新的订阅信息),都代表了消费者有变化了,如果isNotifyConsumerIdsChangedEnable为true的话(默认为true),则会去通知该消费者组的所有消费端去再平衡,后面再调用register方法将订阅信息注册到groupFilterData(这个map不知道干嘛的) 通知客户端再平衡请求编码是NOTIFY_CONSUMER_IDS_CHANGED,值为40,请求体为NotifyConsumerIdsChangedRequestHeader,带有消费者组信息 然后继续看heartBeat方法,后面就是将生产者的连接注册到groupChannelTable中,心跳执行结束,并返回成功给客户端 三、发送消息给broker端客户端请求码SEND_MESSAGE,值为10broker端由SendMessageProcessor进行处理","link":"/2022/01/17/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"排序算法之快速排序","text":"排序算法之快速排序 算法思想快速排序是一种分治思想,将每切分的那一块都按照标准值分好左右.一直切分直到最后就是一个排序好的数组. 例如数组 第一步,选取第一个值5作为标准值 第二步,然后定义左右指针,左指针从1位置往后遍历,右指针从后往前遍历,最终需要左右指针的左边都是比标准值小,右边比标准值大 第三步,左指针遍历到1位置,获取到值8,比标准值大,则该值应该放在左指针的右边,此时左指针暂停遍历. 第四步,开始遍历右指针,右指针获取到值7,比标准值5大,则继续往前遍历,遍历到下一个值为4,比标准5小.则右指针暂停遍历. 第五步,交换左右指针的值,使得左右指针值都可以满足左边比标准值小,右边比标准值大 第六步: 重复上述1~5步,直到最终左指针大于等于右指针 第七步: 比较相遇位置的值与标准值,为了满足标准值左边的值都比标准值小,右边的值都比标准值大.如果相遇位置值比标准值小,则直接与相遇位置值交换,如果比标准值大,则与相遇前一个位置的值交换.此处由于6是比标准值5大的,所以将5与6的前一个值2进行交换. 此时可以看到数组经过多次交换后,已经形成了左边都比标准值小,右边都比标准值大的局面 第八步: 以标准值为界,将数组切成两份 分别对左右两边执行1~8步,直到最终切分出来的子数组只要1个元素或2个元素,那么直接比较交换. 这样最终得到的就是一个排序的数组 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class PivotSort { public static void main(String[] args) { int[] arr = {5, 8, 3, 6, 2, 4, 7}; pivotSort(arr, 0, arr.length); System.out.println(Arrays.toString(arr)); } public static void pivotSort(int[] nums, int start, int end) { //如果给的数组最多只有1个值,那么直接返回 if (end - start &lt;= 0) { return; //如果是两个值那么直接比较 } else if (end - start == 1) { if (nums[end] &lt; nums[start]) { swap(nums, start, end); } } else { //以起始值为标准值 int pivot = nums[start]; //从第一个值往后遍历 int left = start + 1; //从最后第一个值往前遍历 int right = end; while (left &lt; right) { while (left &lt; end &amp;&amp; nums[left] &lt; pivot) { left++; } while (right &gt; start &amp;&amp; nums[right] &gt;= pivot) { right--; } if (left &lt; right) { swap(nums, left, right); } } int pivotPosition = left; //如果左指针已经在右指针之后了 if (left &gt;= right) { //比较基准值与左指针位置值的大小 if (nums[left] &gt;= pivot) { pivotPosition = left - 1; if (left - 1 != start) { swap(nums, start, left - 1); } } else { swap(nums, start, left); } } //以基准值为界,且成两半,继续执行以上步骤 pivotSort(nums, start, pivotPosition - 1); pivotSort(nums, pivotPosition + 1, end); } } /** * 交换值 * @param nums * @param p1 * @param p2 */ private static void swap(int[] nums, int p1, int p2) { nums[p1] = nums[p1] ^ nums[p2]; nums[p2] = nums[p1] ^ nums[p2]; nums[p1] = nums[p1] ^ nums[p2]; }}","link":"/2021/12/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"rocketmq源码梳理之push模式消费者的建立","text":"rocketmq push消费模式消费者的建立过程 示例代码 //使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); //设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); //启动消费者消费 consumer.start(); 代码的执行流程1. 消费者对象的初始化//使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); 进入DefaultMqPushConsumer对象,可以看到声明了很多成员变量并初始化了默认值.整理如下: 变量名 变量类型 变量含义 默认值 messageModel MessageModel 消费消息的模式,有两种配置,集群和广播 集群,MessageModel.CLUSTERING consumeFromWhere ConsumeFromWhere 从何处开始消费,配置值有从最开始、从最新、从指定时间戳 从最新处,ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET; consumeTimestamp String 消费时间戳,yyyyMMddHHmmss格式 当前时间往前推30分钟 consumeThreadMin int 消费线程最小值 20 consumeThreadMax int 消费线程最大值 20 adjustThreadPoolNumsThreshold int 动态调整线程池数量的阈值 10000 consumeConcurrentlyMaxSpan int 并发消费最大数据量 2000 pullThresholdForQueue int 队列缓存的最大消息量 1000 pullThresholdSizeForQueue int 队列拉取的消息的大小阈值,单位为MB 100 pullThresholdForTopic int topic一次性拉取的最大消息量,例如改值设置1000时,而有10个队列的话,则每个队列最大只能拉取100个,相当于pullThresholdForQueue 设置了100 -1,不限制 pullInterval long 拉取间隔 0,拉取后不等待 consumeMessageBatchMaxSize int 消费的批量大小 1 pullBatchSize int 批量拉取大小 32 postSubscriptionWhenPull boolean 拉取的时候是否提交订阅信息 false unitMode boolean 单元模式 false maxReconsumeTimes int 最大重试次数,有序消费时,-1代表无穷大,无序消费时,-1代表16次 -1 suspendCurrentQueueTimeMillis long —- 1000 consumeTimeout long 消费超时时间,单位分钟 15 awaitTerminationMillisWhenShutdown long 停止时暂停等消费时间,0就是不等待 0 同时DefaultMqPushConsumer对象继承了ClientConfig对象,该对象也模式初始化了一些配置,整理如下 变量名 变量类型 变量含义 默认值 namesrvAddr String 元数据服务器地址 从系统参数rocketmq.namesrv.addr中获取,获取不到就从环境变量NAMESRV_ADDR中获取 clientIP String 客户端ip 通过RemotingUtil.getLocalAddress()获取 instanceName String 实例名称 从系统参数rocketmq.client.name中获取,获取不到就使用默认名称DEFAULT clientCallbackExecutorThreads int 客户端回调执行的线程数 通过Runtime.getRuntime().availableProcessors()获取 accessChannel AccessChannel 访问通道,可选值有LOCAL和CLOUD AccessChannel.LOCAL pollNameServerInterval long 从元数据服务器拉取信息间隔 30000,单位毫秒 heartbeatBrokerInterval long 心跳间隔时间 30000,单位毫秒 persistConsumerOffsetInterval long 消费位移持久化间隔 5000,单位毫秒 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 1000,单位毫秒 unitMode boolean 单元模式 false vipChannelEnabled boolean 是否开启vip通道 从系统参数com.rocketmq.sendMessageWithVIPChannel获取,获取不到默认值为false useTLS boolean 是否使用tls安全协议 从系统参数tls.enable获取,获取不到默认值为false mqClientApiTimeout long 客户端超时时间 3000,单位毫秒 language LanguageCode 代码语言 LanguageCode.JAVA 调用了另一个重载的构造方法,并设置了默认的再平衡策略AllocateMessageQueueAveragely 重载的构造方法初始化了DefaultMQPushConsumerImpl对象 DefaultMQPushConsumerImpl对象初始化了设置了pullTimeDelayMillsWhenException,该参数为当出现异常时,拉取消息推迟多少秒,默认值从ClientConfig中获取的,为1000毫秒同时该类也默认初始化了不少配置,整理如下: 变量名 变量类型 变量含义 默认值 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 3000,单位毫秒,但是在构造函数执行时,默认会重新赋值,改为ClientConfig中的默认值,为1000 PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL long 出现流量控制后拉取延迟时间 50,单位毫秒 PULL_TIME_DELAY_MILLS_WHEN_SUSPEND long 当消费端暂停后拉取延迟时间 1000,单位毫秒 BROKER_SUSPEND_MAX_TIME_MILLIS long 节点暂停最大时间 15000,单位毫秒 CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND long 当暂停时消费超时时间 30000,单位毫秒 rebalanceImpl RebalanceImpl 再平衡类 RebalancePushImpl,传入了当前对象构造 consumerStartTimestamp long 消费开始时间戳 System.currentTimeMillis(),当前时间 serviceState ServiceState 消费者当前状态,值有CREATE_JUST(创建未启动) 、RUNNING(正在运行)、SHUTDOWN_ALREADY(已经停止)、START_FAILED(启动失败) ServiceState.CREATE_JUST 至此DefaultMQPushConsumer对象初始化完毕,该环节主要是初始化一些配置以及关联对象的一些配置 2. 个性化配置//设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); 对于一些配置的设置只是改变了下配置值,如上面的设置起始位置,在具体用到的时候会生效.可设置的配置可以关注下上面梳理的各个对象初始化的配置. 3. 配置订阅信息和回调函数//设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); 继续调用了DefaultMQPushConsumerImpl对象的subscribe方法,另外此处通过调用withNamespace方法对topic名称进行包装,就是给topic名称前再加上命名空间的值,如命名空间为aaa,topic为test,此处就会包装成aaa%topic,通过配置命名空间,可以在不改动代码的情况下,切换mq的消费环境 首先使用FilterAPI.buildSubscriptionData(topic, subExpression)生成订阅对象SubscriptionData.该对象保存了订阅的topic,以及配置的过滤表达式,如果指定了tag,将会把tag放入tagSet中,并且将tag的hash值放入codeSet中用以过滤.将subscriptionData放入rebalanceImpl的subscriptionInner成员变量中,这是一个map,key为topic,值为订阅对象此时mQClientFactory对象还未初始化,所以此时还不执行 然后将消费到消息后的回调函数复制给DefaultMQPushConsumer和DefaultMQPushConsumerImpl对象的messageListener对象中 4. 启动消费者//启动消费者消费 consumer.start(); 跟之前的topic一样,给消费者组名加上namespace值然后执行defaultMQPushConsumerImpl的start方法 该方法根据当前服务的状态执行不同的逻辑,由于是刚创建,状态值为CREATE_JUST,所以执行这个分支的逻辑.首先将服务状态修改为START_FAILED再执行后续逻辑,以防止启动异常后重复启动checkConfig检查必要的配置以及配置格式是否正确copySubscription里主要是为当前消费者组增加retry消费者组当消费模式是集群时,调用changeInstanceNameToPID把默认的实例名改为使用进程id 初始化MQClientInstance对象,并以clientId为key,放入factoryTable中.该对象主要用netty与服务端通信 初始化了nettyClientConfig对象,主要配置netty连接的相关配置初始化了ClientRemotingProcessor对象,处理服务端的一些响应逻辑初始化了MQClientAPIImpl,将clientRemotingProcessor的响应逻辑按照响应编码注册到了netty中初始化了MQAdminImpl对象初始化了PullMessageService对象初始化了RebalanceService对象初始化了defaultMQProducer对象初始化了consumerStatsManager对象,可打印状态信息 紧接着主线的初始化给自平衡对象设置消费者组名,消费模式,再平衡策略,以及通信客户端 紧接着初始化了PullAPIWrapper对象紧接着初始化了OffsetStore对象,当下消费模式为集群模式,所以使用了RemoteBrokerOffsetStore. 紧接着根据回调函数类型,来设置消费是否有序,当下为无序消费,ConsumeMessageConcurrentlyService,调用该类的start方法,会启动一个定期执行的线程池,用以清理过期消息 以consumerGroup为key,当前消费者对象为值放入MQClientInstance的consumerTable中 然后调用MQClientInstance的start方法 首先获取元数据服务器地址然后调用mqClientApiImpl的start方法与mq服务端建立netty连接然后启动部分定时任务然后启动拉取线程然后启动再平衡线程然后启动默认的producer线程然后修改服务状态为Running至此初始化结束. 后面都是各个线程执行操作.核心就是以下几个线程 RebalanceService定期再平衡PullMessageService定期拉取数据fetchNameServerAddr定期获取元数据地址updateTopicRouteInfoFromNameServer定期获取topic路由cleanOfflineBroker定期清理下线节点sendHeartbeatToAllBrokerWithLock定期发送心跳线程persistAllConsumerOffset持久化所有消费位移adjustThreadPool定期调整线程池 下面重点介绍这些线程的作用 各线程作用RebalanceService 等待间隔waitInterval,取自系统参数rocketmq.client.rebalance.waitInterval,如果未设置,默认值为20ms 如果hasNotified为true,则不等待直接返回否则等待interval时间再返回 遍历consumerTable,执行每一个消费者对象的doRebalance方法,当前为Push模式的消费者,所以执行DefaultMQPushConsumerImpl的doRebalance方法 最终调用的RebalanceImpl的doRebalance方法,当前是无序 获取订阅信息,根据订阅信息获取topic,然后调用rebalanceByTopic方法,该方法根据消费模式执行不同的再平衡逻辑,当前消费模式是集群 获取当前topic的队列信息获取当前消费者组的各个消费者id根据再平衡策略将队列分配给各个消费者组,当前默认分配策略是平均分配 算法如下:假如有11个队列,4个消费者,平分的话每个消费者能分两个,余数为3.余数的3个再根据消费者顺序按顺序分配给前3个消费者.这样4个消费者分配方案就是3332 给当前消费者分配好消费队列后,与之前分配的队列进行比较.如果之前分配的队列不在新的分配队列里了,则将其移除如果是新添加的队列,则根据消费模式去获取消费的位移,根据配置的消费起始,去计算位移.例如当前配置的是从最开始处获取位移 先从本地获取位移,本地有位移以本地为主,本地要是没位移则如果刚开始新建设置为-1,如果已经设置了-1则从0开始消费 如果位移是大于等于0的,则新建一个PullRequest对象以当前位移开始去拉数据. 如果产生了队列的变化,则执行messageQueueChanged方法通知给服务端根据当前时间戳更新队列的版本号,根据当前队列数量计算pullThresholdForTopic和pullThresholdSizeForTopic然后通过发送心跳包将订阅信息更新给服务端.至此再平衡结束 PullMessageService 从pullRequestQueue中获取pullRequest对象,然后去拉取消息 判断当前ProcessQueue是否还是该消费者消费,如果不是直接返回判断当前消费对象是否是暂停状态,如果是延迟放入队列直接返回根据当前ProcessQueue缓存的消息数量和消息大小判断是否超过了配置的大小,超过则进行流控延迟放入队列直接返回判断当前ProcessQueue的跨度是否超过配置值,超过也进行流控延迟放入队列直接返回获取订阅信息,如果订阅信息为空延迟放入队列直接返回初始化回调函数,用于处理消费到的消息,具体消费逻辑后续再说使用netty客户端拉取消息 可以看到将调用信息封装成了一个ResponseFuture对象,并且在netty调用回调里调用成功和失败通过ResponseFuture执行了不同的逻辑. 在netty客户端对象NettyRemotingClient初始化的时候,也有初始化了一个定时线程 该线程会每秒执行一次,获取ResponseFuture对象,判断消息超时后会同样调用回调逻辑. 此处再看回调函数里的处理 当有响应结果才会去调用Onsuccess方法,其他都是调用OnException 当OnSuccess时会根据获取的响应结果的状态执行不同的逻辑当是Found时,即是拉取到了消息,首先获取下次拉取消息的开始位移,留待后续拉取,然后将拉取到的消息调用consumeMessageService.submitConsumeRequest进行处理,目前消费方式不是有序,使用的是ConsumeMessageConcurrentlyService对象,该方法内部会将拉取到的消息封装成ConsumeRequest对象,该对象是个线程,然后内部处理会调用一开始初始化Consumer对象传入的lisener的cousumerMessage方法进行处理当是NO_NEW_MSG和NO_MATCHED_MSG时,即本次没拉取到消息,则立即再次拉取当时OFFSET_ILLEGAL时,即位移是不合法的,则移除当前的ProcessQueue,当再平衡时会重新分配,重新分配的时候会重新获取最新位移 当OnException时,会打印对应的异常信息,并延迟放入队列等待重新拉取 fetchNameServerAddr定期获取NameServer线程如果NameServer是空,该线程会定期访问配置的接口获取nameserver信息 可以做到在运行过程中切换mq环境 updateTopicRouteInfoFromNameServer定期根据当前消费者所订阅的topic从NameServer中获取元数据信息,包括broker节点信息,队列信息等 cleanOfflineBroker定期清理下线节点 sendHeartbeatToAllBrokerWithLock定期与节点发送心跳信息,将当前消费者的信息发送给broker端 persistAllConsumerOffset定期持久化消费位移到内存offsetStore对象里 adjustThreadPool定期调整线程池大小 内存dump里需要关注的对象MqClientInstance与mq服务端交互的客户端对象,以instanceName确定唯一,每个instanceName会单独建立一个对象 DefaultMQPushConsumerImplpush消费具体处理逻辑的对象,包括调用再平衡,请求消息,处理消息等等 OffsetStore集群模式消费的位移存在RemoteOffsetStore中,在拉取消息的时候会先从服务端同步位移,同步不到位移的时候才会从头开始消费","link":"/2022/01/06/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8Bpush%E6%A8%A1%E5%BC%8F%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%BB%BA%E7%AB%8B/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"java基础","slug":"java基础","link":"/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"lock","slug":"lock","link":"/tags/lock/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}