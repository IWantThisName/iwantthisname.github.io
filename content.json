{"pages":[],"posts":[{"title":"排序算法之快速排序","text":"排序算法之快速排序 算法思想快速排序是一种分治思想,将每切分的那一块都按照标准值分好左右.一直切分直到最后就是一个排序好的数组. 例如数组 第一步,选取第一个值5作为标准值 第二步,然后定义左右指针,左指针从1位置往后遍历,右指针从后往前遍历,最终需要左右指针的左边都是比标准值小,右边比标准值大 第三步,左指针遍历到1位置,获取到值8,比标准值大,则该值应该放在左指针的右边,此时左指针暂停遍历. 第四步,开始遍历右指针,右指针获取到值7,比标准值5大,则继续往前遍历,遍历到下一个值为4,比标准5小.则右指针暂停遍历. 第五步,交换左右指针的值,使得左右指针值都可以满足左边比标准值小,右边比标准值大 第六步: 重复上述1~5步,直到最终左指针大于等于右指针 第七步: 比较相遇位置的值与标准值,为了满足标准值左边的值都比标准值小,右边的值都比标准值大.如果相遇位置值比标准值小,则直接与相遇位置值交换,如果比标准值大,则与相遇前一个位置的值交换.此处由于6是比标准值5大的,所以将5与6的前一个值2进行交换. 此时可以看到数组经过多次交换后,已经形成了左边都比标准值小,右边都比标准值大的局面 第八步: 以标准值为界,将数组切成两份 分别对左右两边执行1~8步,直到最终切分出来的子数组只要1个元素或2个元素,那么直接比较交换. 这样最终得到的就是一个排序的数组 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class PivotSort { public static void main(String[] args) { int[] arr = {5, 8, 3, 6, 2, 4, 7}; pivotSort(arr, 0, arr.length); System.out.println(Arrays.toString(arr)); } public static void pivotSort(int[] nums, int start, int end) { //如果给的数组最多只有1个值,那么直接返回 if (end - start &lt;= 0) { return; //如果是两个值那么直接比较 } else if (end - start == 1) { if (nums[end] &lt; nums[start]) { swap(nums, start, end); } } else { //以起始值为标准值 int pivot = nums[start]; //从第一个值往后遍历 int left = start + 1; //从最后第一个值往前遍历 int right = end; while (left &lt; right) { while (left &lt; end &amp;&amp; nums[left] &lt; pivot) { left++; } while (right &gt; start &amp;&amp; nums[right] &gt;= pivot) { right--; } if (left &lt; right) { swap(nums, left, right); } } int pivotPosition = left; //如果左指针已经在右指针之后了 if (left &gt;= right) { //比较基准值与左指针位置值的大小 if (nums[left] &gt;= pivot) { pivotPosition = left - 1; if (left - 1 != start) { swap(nums, start, left - 1); } } else { swap(nums, start, left); } } //以基准值为界,且成两半,继续执行以上步骤 pivotSort(nums, start, pivotPosition - 1); pivotSort(nums, pivotPosition + 1, end); } } /** * 交换值 * @param nums * @param p1 * @param p2 */ private static void swap(int[] nums, int p1, int p2) { nums[p1] = nums[p1] ^ nums[p2]; nums[p2] = nums[p1] ^ nums[p2]; nums[p1] = nums[p1] ^ nums[p2]; }}","link":"/2021/12/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"rocketmq源码梳理之push模式消费者的建立","text":"rocketmq push消费模式消费者的建立过程 示例代码 //使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); //设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); //启动消费者消费 consumer.start(); 代码的执行流程1. 消费者对象的初始化//使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); 进入DefaultMqPushConsumer对象,可以看到声明了很多成员变量并初始化了默认值.整理如下: 变量名 变量类型 变量含义 默认值 messageModel MessageModel 消费消息的模式,有两种配置,集群和广播 集群,MessageModel.CLUSTERING consumeFromWhere ConsumeFromWhere 从何处开始消费,配置值有从最开始、从最新、从指定时间戳 从最新处,ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET; consumeTimestamp String 消费时间戳,yyyyMMddHHmmss格式 当前时间往前推30分钟 consumeThreadMin int 消费线程最小值 20 consumeThreadMax int 消费线程最大值 20 adjustThreadPoolNumsThreshold int 动态调整线程池数量的阈值 10000 consumeConcurrentlyMaxSpan int 并发消费最大数据量 2000 pullThresholdForQueue int 队列缓存的最大消息量 1000 pullThresholdSizeForQueue int 队列拉取的消息的大小阈值,单位为MB 100 pullThresholdForTopic int topic一次性拉取的最大消息量,例如改值设置1000时,而有10个队列的话,则每个队列最大只能拉取100个,相当于pullThresholdForQueue 设置了100 -1,不限制 pullInterval long 拉取间隔 0,拉取后不等待 consumeMessageBatchMaxSize int 消费的批量大小 1 pullBatchSize int 批量拉取大小 32 postSubscriptionWhenPull boolean 拉取的时候是否提交订阅信息 false unitMode boolean 单元模式 false maxReconsumeTimes int 最大重试次数,有序消费时,-1代表无穷大,无序消费时,-1代表16次 -1 suspendCurrentQueueTimeMillis long —- 1000 consumeTimeout long 消费超时时间,单位分钟 15 awaitTerminationMillisWhenShutdown long 停止时暂停等消费时间,0就是不等待 0 同时DefaultMqPushConsumer对象继承了ClientConfig对象,该对象也模式初始化了一些配置,整理如下 变量名 变量类型 变量含义 默认值 namesrvAddr String 元数据服务器地址 从系统参数rocketmq.namesrv.addr中获取,获取不到就从环境变量NAMESRV_ADDR中获取 clientIP String 客户端ip 通过RemotingUtil.getLocalAddress()获取 instanceName String 实例名称 从系统参数rocketmq.client.name中获取,获取不到就使用默认名称DEFAULT clientCallbackExecutorThreads int 客户端回调执行的线程数 通过Runtime.getRuntime().availableProcessors()获取 accessChannel AccessChannel 访问通道,可选值有LOCAL和CLOUD AccessChannel.LOCAL pollNameServerInterval long 从元数据服务器拉取信息间隔 30000,单位毫秒 heartbeatBrokerInterval long 心跳间隔时间 30000,单位毫秒 persistConsumerOffsetInterval long 消费位移持久化间隔 5000,单位毫秒 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 1000,单位毫秒 unitMode boolean 单元模式 false vipChannelEnabled boolean 是否开启vip通道 从系统参数com.rocketmq.sendMessageWithVIPChannel获取,获取不到默认值为false useTLS boolean 是否使用tls安全协议 从系统参数tls.enable获取,获取不到默认值为false mqClientApiTimeout long 客户端超时时间 3000,单位毫秒 language LanguageCode 代码语言 LanguageCode.JAVA 调用了另一个重载的构造方法,并设置了默认的再平衡策略AllocateMessageQueueAveragely 重载的构造方法初始化了DefaultMQPushConsumerImpl对象 DefaultMQPushConsumerImpl对象初始化了设置了pullTimeDelayMillsWhenException,该参数为当出现异常时,拉取消息推迟多少秒,默认值从ClientConfig中获取的,为1000毫秒同时该类也默认初始化了不少配置,整理如下: 变量名 变量类型 变量含义 默认值 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 3000,单位毫秒,但是在构造函数执行时,默认会重新赋值,改为ClientConfig中的默认值,为1000 PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL long 出现流量控制后拉取延迟时间 50,单位毫秒 PULL_TIME_DELAY_MILLS_WHEN_SUSPEND long 当消费端暂停后拉取延迟时间 1000,单位毫秒 BROKER_SUSPEND_MAX_TIME_MILLIS long 节点暂停最大时间 15000,单位毫秒 CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND long 当暂停时消费超时时间 30000,单位毫秒 rebalanceImpl RebalanceImpl 再平衡类 RebalancePushImpl,传入了当前对象构造 consumerStartTimestamp long 消费开始时间戳 System.currentTimeMillis(),当前时间 serviceState ServiceState 消费者当前状态,值有CREATE_JUST(创建未启动) 、RUNNING(正在运行)、SHUTDOWN_ALREADY(已经停止)、START_FAILED(启动失败) ServiceState.CREATE_JUST 至此DefaultMQPushConsumer对象初始化完毕,该环节主要是初始化一些配置以及关联对象的一些配置 2. 个性化配置//设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); 对于一些配置的设置只是改变了下配置值,如上面的设置起始位置,在具体用到的时候会生效.可设置的配置可以关注下上面梳理的各个对象初始化的配置. 3. 配置订阅信息和回调函数//设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); 继续调用了DefaultMQPushConsumerImpl对象的subscribe方法,另外此处通过调用withNamespace方法对topic名称进行包装,就是给topic名称前再加上命名空间的值,如命名空间为aaa,topic为test,此处就会包装成aaa%topic,通过配置命名空间,可以在不改动代码的情况下,切换mq的消费环境 首先使用FilterAPI.buildSubscriptionData(topic, subExpression)生成订阅对象SubscriptionData.该对象保存了订阅的topic,以及配置的过滤表达式,如果指定了tag,将会把tag放入tagSet中,并且将tag的hash值放入codeSet中用以过滤.将subscriptionData放入rebalanceImpl的subscriptionInner成员变量中,这是一个map,key为topic,值为订阅对象此时mQClientFactory对象还未初始化,所以此时还不执行 然后将消费到消息后的回调函数复制给DefaultMQPushConsumer和DefaultMQPushConsumerImpl对象的messageListener对象中 4. 启动消费者//启动消费者消费 consumer.start(); 跟之前的topic一样,给消费者组名加上namespace值然后执行defaultMQPushConsumerImpl的start方法 该方法根据当前服务的状态执行不同的逻辑,由于是刚创建,状态值为CREATE_JUST,所以执行这个分支的逻辑.首先将服务状态修改为START_FAILED再执行后续逻辑,以防止启动异常后重复启动checkConfig检查必要的配置以及配置格式是否正确copySubscription里主要是为当前消费者组增加retry消费者组当消费模式是集群时,调用changeInstanceNameToPID把默认的实例名改为使用进程id 初始化MQClientInstance对象,并以clientId为key,放入factoryTable中.该对象主要用netty与服务端通信 初始化了nettyClientConfig对象,主要配置netty连接的相关配置初始化了ClientRemotingProcessor对象,处理服务端的一些响应逻辑初始化了MQClientAPIImpl,将clientRemotingProcessor的响应逻辑按照响应编码注册到了netty中初始化了MQAdminImpl对象初始化了PullMessageService对象初始化了RebalanceService对象初始化了defaultMQProducer对象初始化了consumerStatsManager对象,可打印状态信息 紧接着主线的初始化给自平衡对象设置消费者组名,消费模式,再平衡策略,以及通信客户端 紧接着初始化了PullAPIWrapper对象紧接着初始化了OffsetStore对象,当下消费模式为集群模式,所以使用了RemoteBrokerOffsetStore. 紧接着根据回调函数类型,来设置消费是否有序,当下为无序消费,ConsumeMessageConcurrentlyService,调用该类的start方法,会启动一个定期执行的线程池,用以清理过期消息 以consumerGroup为key,当前消费者对象为值放入MQClientInstance的consumerTable中 然后调用MQClientInstance的start方法 首先获取元数据服务器地址然后调用mqClientApiImpl的start方法与mq服务端建立netty连接然后启动部分定时任务然后启动拉取线程然后启动再平衡线程然后启动默认的producer线程然后修改服务状态为Running至此初始化结束. 后面都是各个线程执行操作.核心就是以下几个线程 RebalanceService定期再平衡PullMessageService定期拉取数据fetchNameServerAddr定期获取元数据地址updateTopicRouteInfoFromNameServer定期获取topic路由cleanOfflineBroker定期清理下线节点sendHeartbeatToAllBrokerWithLock定期发送心跳线程persistAllConsumerOffset持久化所有消费位移adjustThreadPool定期调整线程池 下面重点介绍这些线程的作用 各线程作用RebalanceService 等待间隔waitInterval,取自系统参数rocketmq.client.rebalance.waitInterval,如果未设置,默认值为20ms 如果hasNotified为true,则不等待直接返回否则等待interval时间再返回 遍历consumerTable,执行每一个消费者对象的doRebalance方法,当前为Push模式的消费者,所以执行DefaultMQPushConsumerImpl的doRebalance方法 最终调用的RebalanceImpl的doRebalance方法,当前是无序 获取订阅信息,根据订阅信息获取topic,然后调用rebalanceByTopic方法,该方法根据消费模式执行不同的再平衡逻辑,当前消费模式是集群","link":"/2022/01/06/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8Bpush%E6%A8%A1%E5%BC%8F%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%BB%BA%E7%AB%8B/"}],"tags":[{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"}]}