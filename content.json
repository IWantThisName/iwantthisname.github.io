{"pages":[],"posts":[{"title":"juc包之CountDownLatch与CyclicBarrier","text":"CountDownLatch与CyclicBarrier各自的实现原理 CountDownLatch类示例代码: (在CountDownLatch类的注释上方提供了两种使用方式) 第一种 class Driver { void main() throws InterruptedException { CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i &lt; N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); startSignal.countDown(); doSomethingElse(); doneSignal.await(); } } class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) { this.startSignal = startSignal; this.doneSignal = doneSignal; } public void run() { try { startSignal.await(); doWork(); doneSignal.countDown(); } catch (InterruptedException ex) {} } void doWork() { //something to do } } 先让所有Worker等Driver去唤醒,然后Driver等所有Worker执行完再唤醒 第二种 class Driver2 { // ... void main() throws InterruptedException { CountDownLatch doneSignal = new CountDownLatch(N); Executor e = ... for (int i = 0; i &lt; N; ++i) // create and start threads e.execute(new WorkerRunnable(doneSignal, i)); doneSignal.await(); // wait for all to finish } } class WorkerRunnable implements Runnable { private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) { this.doneSignal = doneSignal; this.i = i; } public void run() { try { doWork(i); doneSignal.countDown(); } catch (InterruptedException ex) {} // return; } void doWork() { ... } } 让Drive等待所有Worker运行完毕(注释说这种写法可以用CyclicBarrier代替) 看一下几个核心方法 CountDownLatch构造方法 初始化主要是给state变量设置了值,并且该值不能小于0 CountDownLatch的countdown方法 countdown执行了Sync内部类的releaseShared方法,该方法先执行了tryReleaseShared方法,返回true才会去执行doReleaseShared方法 该方法首先判断state值是否为0,如果为0,直接返回false,代表没有资源可以释放了,要是不为0,则将state值减1,并将结果更新给state变量,然后判断-1后的值是否为0,如果为0,则返回true.所以返回true的含义就是在此次释放资源后已经没有需要释放的资源了. 该方法是在资源全部被释放后才会执行的.首先获取队列的head节点,并且判断head节点不为null也不为tail(head只有已经唤醒过才有可能与tail节点相同).然后获取head的waitStatus.如果waitStatus是Signal则会去唤醒该节点线程,如果执行期间head节点被替换了,则会继续循环,否则就跳出. CountDownLatch的await方法 await执行了Sync内部类的acquireSharedInterruptibly方法,该方法首先判断当前线程是否中断了,如果中断直接抛出错误,否则执行tryAcquireShared方法,当返回负数时才会去执行doAcquireSharedInterruptibly方法 判断当前state变量值是否为0,只有当不为0才会返回负数-1,代表还有资源未释放 该方法内部与ReentranLock类的acquiredQueued很像,都是遍历链表节点,去获取资源,获取失败则会调用LockSupport的park方法将其挂起,且设置节点为SIGNAL.获取成功则会调用setHeadAndPropagate方法将所有未取消的节点都唤醒","link":"/2022/01/19/juc%E5%8C%85%E4%B9%8BCountDownLatch%E4%B8%8ECyclicBarrier/"},{"title":"juc包之ReentrantLock","text":"jdk1.5之后新增了ReentrantLock类，可以在代码里更灵活的控制同步代码块，那么这一块是如何实现的呢？ 示例代码 ReentrantLock reentrantLock = new ReentrantLock(); reentrantLock.lock(); try { //something to do } finally { reentrantLock.unlock(); } 第一行初始化类对象 可以看到默认构造函数初始化的是一个非公平锁 还有一个重载的构造函数，通过传入布尔值，来控制初始化公平锁还是非公平锁，接下来先看非公平锁的实现第二行上锁 此处接着执行非公平锁的lock方法 首先执行compareAndSetState方法将state变量从0变成1，一开始state变量值默认为0，所以第一个执行lock方法的线程将会执行成功，然后执行setExclusiveOwnerThread方法，将当前线程对象赋值到exclusiveOwnerThread变量上，代表当前独占的线程。假如在之前已经有线程执行过lock方法了，已经修改过state变量值了，此时compareAndSetState方法就会执行失败，走下方acquire方法逻辑,acquire方法为从非公平锁父类AbstractQueuedSynchronizer继承而来的方法 首先执行tryAcquire方法，此处最终调用到了Sync类的nonfairTryAcquire方法 先获取当前执行的线程，再获取当前的state值。如果state值为0，代表在这期间占有锁的线程已经释放锁了，则跟lock方法一样，首先调用compareAndSetState方法修改state变量的值，修改成功则调用setExclusiveOwnerThread修改当前独占锁的线程对象，并返回true代表获取锁成功。如果state值不为0，但当前请求锁的线程就是当前锁的独占线程，即拥有锁的线程又一次请求了锁，则给state值加上请求的资源数，并判读state值是否溢出了，如果溢出则代表当前线程请求锁资源过多，则直接抛出错误（此处溢出得这个线程请求锁超过21亿次，挺难的）。没有溢出则去修改state值，并返回true。如果以上两种方式都不符合，则返回false，代表获取锁失败。（在这里的第一种判断是假设在执行后续逻辑前其他线程又释放了锁，则可以执行上锁并返回，第二种判断是为了实现锁的可重入，如果还是当前持有锁的线程在获取锁，则可以继续让它上锁） 再执行acquireQueued方法，在执行前先执行了addWaiter方法，并说明是独占节点。 先看addWaiter方法 先构造Node节点，传入当前线程对象，以及锁类型，此处为Exclusive独占然后将当前链表最后一个节点赋值给pred变量，如果pred变量不为null，则将node的前继节点设置为pred，并且将node设置成链表的最后一个节点，如果设置成功将之前链表的最后一个节点的后驱指向node，并返回node。(即是将node追加到链表的最后一个，并且将node赋值给代表链表最后一个节点的变量)如果pred变量为null，或者之前设置tail节点失败的话，则调用enq方法传入node节点，并返回node enq方法内部是个死循环，首先判断tail变量是否有值，如果无值则代表之前都还没有链表，则新建了一个node对象设置到head变量，代表是头节点，同时当下只有一个节点，则head也是tail。然后第二次循环时，tail变量将不再是null，此时执行上面的逻辑，将当前node设置成tail，并链接到上一个tail变量后形成链表。 再看acquireQueued方法 在死循环里，首先获取节点的前继，head节点由于在上面链表初始化的时候是单独new没有其他作用，所以此处判断前继是head节点时，即代表当前节点是第一个排队等待锁的，则调用tryAcquire方法去获取锁。如果获取成功的话，则将当前节点设置成head了，并返回false，代表不中断。如果前一个节点不是head节点或者获取锁失败的话，则调用shouldParkAfterFialedAcquire方法 会判断前继节点的waitStatus状态，首先判断是否是signal状态（该值为-1，node的初始值是0），接着判断是否大于0，也不满足，则走分支将前继节点的waitStatus修改为signal,并返回false，然后再第二次进入则由于已经改为了signal，则会返回true，然后走parkAndCheckInterrupt方法，该方法将调用LockSupport的park方法挂起当前线程等待其他线程唤醒，如果其他线程唤醒了这个线程，则获取当前线程是否已经被中断了并返回此处还有个逻辑就是前继节点的waitStatus大于0的情况,即前继节点被取消了.则会一直往前遍历,直到遍历到一个未取消的前继节点,然后将其后驱节点设置成当前节点(此处就可以明白为嘛一开始创建链表的head节点为什么要new一个空Node了,空Node的waitStatus要么为0,要么为-1,不可能大于0,这样后面的节点就算全部取消了,一直往前遍历前继节点也不会有null值的情况)（此处看下来感觉也就是挂起有用，判断中断没啥用，也跳不出循环，除非后续真的中断抛出错误了） 这里面的finally模块，感觉只有异常才会执行到cancelAcquire方法(__暂时不看了__） 在acquireQueued方法里如果获取到锁成功返回的话，即lock方法执行完毕不阻塞了，则会继续往下执行同步代码快逻辑。总结如下，调用lock方法首先去修改state变量的值，从0修改到1，修改成功即获取锁，并将当前线程对象设置给锁的独占线程变量上。然后如果修改失败了，则判断当前线程是不是独占锁的那个线程，如果是，则允许重入，即给当前线程放行，state变量继续往上加。如果以上都没成功的话，则将当前线程对象封装成一个node节点，放入锁的链表对象里，按照先入先出的规则，遍历链表的node节点去获取锁，直到获取成功或者线程被中断 第三行释放锁 调用了父类AbstractQueuedSynchronizer继承而来的方法 先看tryRelease方法 计算当前state的值减去释放锁的数量，赋值给c变量，然后先判断当前线程是否是独占线程，不是则抛错。是的话判断c值是否是0，0代表当前线程已经不需要锁了，则设置独占线程变量为null，并设置free变量为true。然后将c变量值赋值给state变量，并返回free的值。 再回头看release方法如果tryRelease返回了false，则代表锁目前还有线程占有，则不做其他处理了如果返回了true，代表锁已经没有线程独占了，则获取head变量，并判断waitStatus状态是否不为0了（在lock时第一次获取不到锁时，会修改node的waitStatus为singal，值为-1），如果是，则调用unarkSuccessor方法 判断节点的waitStatus是否小于0，小于0则改为-1然后获取节点的下一个节点，之前lock方法挂起的就是下一个节点如果下一个节点为null或者waitStatus大于0（大于0只有canceled一种可能），则从tail往前遍历，直到遍历到一个waitStatus的值小于0的然后调用LockSupport的unpark方法去唤醒那个线程.总结: 非公平锁就是先获取锁,并且获取到锁的线程可重复获取锁,然后获取不到锁的线程会形成链表并挂起,当拥有锁的线程将资源全部释放后,会先按照先进先出的原则遍历节点,但当如果正向遍历的节点线程被取消了,则就从尾部反向遍历,直到遍历到一个在等待运行的线程,就去唤醒它.由于每次都是先尝试上锁,上锁失败才会去队列排队,会导致可能新线程直接获取锁成功,队列里的还继续在排队,所以叫非公平锁 再看下公平锁示例代码 ReentrantLock reentrantLock = new ReentrantLock(true); reentrantLock.lock(); try { //something to do } finally { reentrantLock.unlock(); } 在构造ReentrantLock类时传入true,使用公平锁 先看lock方法没有像非公平锁一样先去尝试加锁,而是直接调用了父类AbstractQueuedSynchronizer的acquire方法,跟非公平锁一样,会先调用tryAcquire方法,这个方法公平锁有重载 当state值为0时,首先会调用hasQueuedPredecessors方法,只有当这个方法返回false时,才会往下走去尝试上锁 该方法想返回false,有以下几种情况 head与tail相等 head与tail不等,但是head的下一个节点不为null且下一个节点的线程是当前线程第一种情况是当前没有等待队列了,第二种情况是当前队列在队首(因为head节点都是空Node,head的下一个才算是第一个等待的),所以当前线程都可以继续往下去获取锁.除了获取锁的方式与非公平锁不一样,其他环节都是一样的 总结,公平锁可以看出来不管何时去获取锁,都得先判断当前线程是不是队列里第一个,是才能去获取锁,不是只能加入队列里等待.这样先去申请锁的永远能先运行,所以公平","link":"/2022/01/18/juc%E5%8C%85%E4%B9%8BReentrantLock/"},{"title":"rocketmq源码梳理之producer生产者","text":"rocketmq producer生产者的建立过程以及消息发送流程 示例代码 DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;); producer.start(); for (int i = 0; i &lt; 128; i++) try { { Message msg = new Message(&quot;TopicTest&quot;, &quot;TagA&quot;, &quot;OrderID188&quot;, &quot;Hello world&quot;.getBytes(RemotingHelper.DEFAULT_CHARSET)); SendResult sendResult = producer.send(msg); System.out.printf(&quot;%s%n&quot;, sendResult); } } catch (Exception e) { e.printStackTrace(); } producer.shutdown(); 代码的执行流程生产者对象的初始化DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;); 进入DefaultMqProducer类,发现类的成员变量在初始化的时候设置了不少默认值,整理如下: 变量名 变量类型 变量含义 默认值 retryResponseCodes Set 接受到set里包含的响应码后会进行重试 ResponseCode.TOPIC_NOT_EXIST, ResponseCode.SERVICE_NOT_AVAILABLE, ResponseCode.SYSTEM_ERROR, ResponseCode.NO_PERMISSION, ResponseCode.NO_BUYER_ID, ResponseCode.NOT_IN_CURRENT_UNIT createTopicKey String 自动会创建的topic名称 TBW102 defaultTopicQueueNums int topic默认的队列数 4 sendMsgTimeout long 发送消息的超时时间,默认单位毫秒 3000 compressMsgBodyOverHowmuch long 超过该值配置大小,消息会进行压缩,单位byte 4096 retryTimesWhenSendFailed int 发送失败后重试的次数 2 retryTimesWhenSendAsyncFailed int 异步发送失败后重试的次数 2 retryAnotherBrokerWhenNotStoreOK boolean 发送失败后是否切换到另一个节点发送 false maxMessageSize long 消息最大大小,单位byte 1024 * 1024 * 4 该类继承了ClientConfig类,该类初始化时也初始化了部分默认配置.并且在最终的构造方法中初始化了DefaultMQProducerImpl类,该类具体实现了生产者的一些逻辑 生产者的启动执行的DefaultMQProducerImpl类的start方法 先调用checkConfig方法检查必要配置是否配置再判断当前的消费者组名是否是CLIENT_INNER_PRODUCER,如果不是则更改当前生产者的instanceName,改为用pid+当前纳秒为名根据instanceName获取MqClientInstance对象,如果获取不到,则新建将当前生产者对象放入MqClientInstance的producerTable中,如果放入失败,则代表已经有重名的生产者组初始化过了,抛出错误,否则注册成功然后启动MqClientInstance对象,初始化完毕MqClientInstance对象是与服务端交互的主要对象,初始化流程与push消费者一致 生产者发送消息初始化生产者消息,指定了topic,tag,keys以及消息体其中topic指的是消息的主题,tags指定的消息用于筛选的字段,keys会根据相应规则将消息分配到不同的队列上然后调用producer.send(msg)将消息发送到服务端 此处获取了发送消息的超时时间,如果未设定,默认是3秒 send发送为同步发送,即发送时会阻塞等待发送结果 最终调用DefaultMQProducerImpl的sendDefaultImpl方法执行具体发送逻辑检查生产者状态,如果不在运行状态直接抛错检查消息是否合规获取当前时间作为消息的开始发送时间获取当前topic的发布信息,封装成了TopicPublishInfo对象,该对象可以获取topic的队列信息以及队列处于哪个broker下获取重试次数,如果是同步发送,则重试次数为1+retryTimesWhenSendFailed,如果不是同步发送,则为1次根据规则获取一个队列.默认规则是TopicPublishInfo里有个累加器,每次按顺序从messageQueueList中获取一个MessageQueue用于发送,如果之前发送失败,重试重新获取的,则按照累加器的值继续往下获取,直到获取到一个不是之前队列的进行发送 判断当前时间与上一次开始发送时间的差值是否超过了超时时间,超过了则直接跳出循环然后调用sendKernelImpl方法发送消息将当前时间作为发送完成时间更新延迟时间到FaultItem对象(暂不知道干啥用)根据通信方式,当前是同步,判断响应结果是否发送成功,如果不是且配置发送失败重试的话,则继续循环,如果发送成功,则直接返回发送结果. 接下来详细看下sendKernelImpl的方法 根据brokerName获取broker的地址,如果地址获取不到,则从服务端再根据topic拉取一次topic的发布信息,然后再获取一次brokerAddr如果brokerAddr不为null,判断是否使用虚拟通道发送消息,如果是,则将broker的端口号-2,如果不是,则对brokerAddr不做改变(暂不知道有啥用途)如果当前消息不是MessageBatch,则为消息生成一个唯一id判断消息是否超过配置的compressMsgBodyOverHowmuch大小,如果超过,则对消息体进行压缩,并修改对应标志位判断是否是事务消息,如果是,修改对应标志位调用checkForbiddenHook回调调用sendMessageHook的sendMessageBefor回调封装SendMessageRequestHeader对象发送给服务端 生成请求报文对象 在发送前再判断是否已经超过超时时间","link":"/2022/01/17/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8Bproducer%E7%94%9F%E4%BA%A7%E8%80%85/"},{"title":"jvm-sandbox源码解析","text":"jvm如何在运行时动态的修改字节码内容呢? javaagent机制分为两种加载方式命令行启动: 会根据META-INF文件,找到PERMAIN-CLASS配置的类,去执行类对应的permain方法attach(远程): 会根据META-INF文件,找到AGENTMAIN-CLASS配置的类,去执行类对应的agentmain方法 下面都以attach方式启动为说明 先看sandbox.sh启动脚本,启动的是sandbox-core.jar,并在其后传了很多参数,分别是目标的jvm进程id,sandbox-agent.jar的目录,sandbox的主目录,目标的jvm所在服务器ip,目标的jvm所在服务器端口,命名空间 接下来看下sandbox-core.jar的入口类,在其pom文件中配置的是com.alibaba.jvm.sandbox.core.CoreLauncher 该类main方法最终了执行了这个方法,初始化了VirtualMachine类,并且启动脚本传入的sandbox-agent.jar类和一些配置参数传给了远程jvm进行加载 接下来去看sandbox-agent做了哪些操作,这时候sandbox-agent.jar类所有的操作都已经是在远程jvm中生效了 在其pom文件中配置了agent-class为com.alibaba.jvm.sandbox.agent.AgentLauncher,那么由于是attach方式,将会执行这个类的agentmain方法 核心是这个方法的install方法,它主要做了以下几件事 根据启动脚本传入的jvm-sandbox主目录,将其lib下的sandbox-spy.jar交由远程jvm的启动类加载器进行加载,主要是加载Spy类 构造自定义的类加载器SandboxClassLoader 使用SandboxClassLoader加载com.alibaba.jvm.sandbox.core.CoreConfigure 然后反射调用CoreConfigure的toConfigure方法,并传入启动脚本传入的参数和配置的propertiesPath,构造CoreConfigure对象 使用SandboxClassLoader加载com.alibaba.jvm.sandbox.core.server.ProxyCoreServer 反射调用ProxyCoreServer的getInstance方法,获取ProxyCoreServer实例 然后调用ProxyCoreServer的isBind方法判断是否已经绑定 如果isBind方法调用返回false的话,则反射调用bind方法执行后续逻辑(核心流程) ProxyCoreServer是一个包装类,在其getInstance方法内部调用了JettyCoreServer的getInstance方法,初始化了JettyCoreServer对象,所以bind方法实际调用的是JettyCoreServer的bind方法 bind方法的执行流程如下 使用Initializer类进行一些初始化(后续详细展开),初始化了JvmSandbox类,初始化了HttpServer,并配置了一些接口 调用JvmSandbox的CoreModuleManager初始化模块 先看JvmSandbox类的初始化 初始化EventListenerHandler类,这是个单例类 将CoreConfigure配置类赋值给成员变量cfg 使用静态代理模式代理了DefaultCoreModuleManager对象(这个看就是在调用每个方法之前计数了一下调用次数),在初始化DefaultCoreModuleManager对象时,传入构造函数时同时初始化了DefaultCoreLoadedClassDataSource和DefaultProviderManager对象,DefaultCoreLoadedClassDataSource对象传入了配置赋值给成员变量,DefaultProviderManager对象传入了配置,根据配置的provider路径,加载其下的jar包,并将配置类对象注入给jar包里的ModuleJarLoadingChain和ModuleLoadingChain类中带有Resource注解的ConfigInfo字段(或者字段是ConfigInfo类的父类) 提前加载一些必要的类,com.alibaba.jvm.sandbox.core.util.SandboxClassUtils和com.alibaba.jvm.sandbox.core.util.matcher.structure.ClassStructureImplByAsm 调用SpyUtils的init方法,传入命名空间,本质上是给spy类传入EventListenerHandler类 再看HttpServer的初始化 就是新建了一个Jetty对象,根据启动脚本传入的目标的jvm所在服务器ip,目标的jvm所在服务器端口进行初始化 为服务器初始化了几个接口然后就启动了这个jetty服务 接下来看CoreModuleManager初始化模块流程 首先卸载了所有模块 然后遍历moduleLibDirArray(该集合是DefaultCoreModuleManager初始化时将配置的sytem_module和user_module路径下所有jar路径组成的一个集合),判断路径存在且可读,就调用ModuleLibLoader类的load方法去加载module,初始化了InnerModuleJarLoadCallback和InnerModuleLoadCallback两个回调 首先回调InnerModuleJarLoadCallback的onload方法,传入module jar包路径 再调用DefaultProviderManager对象的loading方法,传入module jar包路径遍历moduleJarLoadingChains集合,并调用每一个方法的loading方法(此处不知道干嘛,暂时不管了,且该集合也是之前初始化DefaultProviderManager类时遍历provider路径时加入的) 再就是调用ModuleJarLoader的load方法,传入module jar路径和配置信息,并传入InnerModuleLoadCallback回调 使用ModuleJarClassLoader类加载加载module jar,然后取出其中所有的Module对象,进行遍历.首先判断是否加了Information注解,没有加则跳过.再取出Information注解上配置的id值,如果没配置也跳过.再判断当前环境的注入模式与Information上配置的是否一致(agent和attach方式要保持一致),如果不一致也跳过.然后回调InnerModuleLoadCallback的onload方法,传入唯一id,module的class对象,module对象,module jar路径的文件对象.ModuleJarClassLoader类加载器. 再看InnerModuleLoadCallback的onload方法 首先判断这个id的module是否已经加载过,如果已经加载过,则跳过.然后遍历DefaultProviderManager类的moduleLoadingChains集合,调用其loading方法,传入一些信息.再调用load方法去加载module 再判断一下id,看module是否已经加载过,加载过,跳过(这一块重复判断了下,应该是为了防止在上面方法执行期间,有其他线程已经初始化了,这个方法加了 synchronized,所以这个方法是不会有多个线程同时执行的)初始化了CoreModule对象,传入了唯一id,module的class对象,module对象和注入模式.然后调用injectResourceOnLoadIfNecessary方法,该方法反射获取了module类的所有加了Resource注解的字段,并根据字段的类型,将各种类对象设置为值.然后回调Module的onLoad方法,标记Module状态为已加载.再调用markActiveOnLoadIfNecessary方法,该方法判断Information的isActiveOnLoad值是否配置了为true(默认为true),是则调用active方法去激活Module(核心流程,后续详细展开)以id为key,module对象为value,放入loadedModuleBOMap中,用于后续判断,防止重复加载.然后如果module是LoadCompleted类的子类,则回调Module的loadCompleted方法. 接下来看Module是怎么active的 首先判断该module状态,如果已经激活过了,则直接返回.然后回调module的onActive方法.遍历sandboxClassFileTransformers集合,将sandboxClassFileTransformers的listenerId,eventListener和eventTypeArray传给EventListenerHandler,EventListenerHandler将这些信息放入了mappingOfEventProcessor集合,key为ListenerId,值为EventProcessor对象.标记module状态为已激活. 上面有个sandboxClassFileTransformers集合,但是集合值是什么时候加进去的呢?其实在上面InnerModuleLoadCallback的injectResourceOnLoadIfNecessary里有进行判断,如果字段是ModuleEventWatcher类型的话,则会初始化一个DefaultModuleEventWatcher对象并赋值给这个字段. 该类通过jvm-sandbox为其注入DefaultModuleEventWatcher对象,并实现了LoadCompleted方法.在方法内构造了EventWatchBuilder对象,并传入了DefaultModuleEventWatcher,最终调用了onWatch方法,并传入的一个回调函数. 最终调用到了DefaultModuleEventWatcher的watch方法.其构造了一个SandboxClassFileTransformer对象,并将其加入到了sandboxClassFileTransformers集合.并将该SandboxClassFileTransformer加到了Instrumentation里,接下来jvm加载的类都会传递给SandboxClassFileTransformer的transform方法.接下来获取到所有需要渲染的类,并计数影响的类数量和方法数量.如果EventWatchBuilder构造是传入了Progress对象,则会在渲染开始、期间、失败和结束回调Progress对象的对应方法,传入进度 在上面需要关注SandboxClassFileTransformer类的transform方法,是怎么回调的,其次需要关注是如何找到需要渲染的类的. 首先看SandboxClassFileTransformer的transform方法. 在transform方法内部,首先根据类的结构,去判断是否有自己需要的条件,如果没有,则直接跳过,如果有的话,则会通过asm字节码编织技术,去修改目标类的字节码,主要是通过EventWeaver这个类,在解析目标类字节码文件时,每次解析method时,都会调用EventWeaver的visitMethod方法,在该方法里,会判断方法名是否是自己需要修改的方法,如果是则对这个方法代码进行修改.修改其实就是在各个环节调用Spy类定义的那几个环节方法,并将对应参数值传入. 再看是如何找到渲染的类的 通过Instrumentation获取jvm加载的所有类,然后遍历类结构,判断类是否是自己需要渲染的目标类,如果是则加入集合,然后再后续通过Instrumentation类让目标类重新加载,一旦重新加载,就会走之前定义的SandboxClassFileTransformer的transform方法,然后对目标类的目标方法进行了修改,以此达到了加强目标类的目的.","link":"/2022/01/30/jvm-sandbox%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"rocketmq源码梳理之服务端的处理","text":"MqClientInstance维护了与服务端的连接,并且生产者和消费者都通过它与服务端进行交互,那么客户端请求的各个功能服务端那边是如何处理的呢? 客户端建立连接代码NettyRemotingClient类,与nameSrv通过netty建立连接NettyEncoder负责消息的编码NettyDecoder负责消息的解码IdleStateHandler负责空闲连接的处理NettyConnectManageHandler负责连接事件的回调处理NettyClientHandler负责对响应消息的处理 服务端监听连接代码NettyRemotingServer类,监听连接NettyEncoder负责消息的编码NettyDecoder负责消息的解码IdleStateHandler负责空闲连接的处理NettyConnectManageHandler负责连接事件的回调处理NettyServerHandler负责对响应消息的处理 一、从namesrv获取topic的路由信息客户端有一个定时器定期调用,由pollNameServerInterval控制调用周期,默认为30s,调用代码如下调用对象GetRouteInfoRequestHeader,只有一个成员变量topic 调用编码GET_ROUTEINFO_BY_TOPIC,值为105 客户端通过NettyEncoder生成报文并发送请求到namesrv,namesrv的NettyDecoder收到报文并解析,解析成功后由NettyServerHandler进行处理 此处收到的请求报文,所以执行processRequestCommand方法 由于namesrv只注册了defaultRequestProcessor,所以此处由defaultRequestProcessor进行处理,并且新建了一个Runnable对象,异步执行请求并且defaultRequestProcessor继承了AsyncNettyRequestProcessor类,所以执行这个分支代码. 并且defaultRequestProcessor的isRejectRquest方法固定返回false,所以不会进行流控然后将处理任务提交到线程池中进行处理,处理逻辑执行defaultRequestProcessor的processRequest方法 此处根据请求的编码走具体的处理分支,此处调用getRouteInfoByTopic方法 TopicRouteData对象里有四个成员变量 orderTopicConf (暂不知道什么作用)queueDatas topic的所有队列信息brokerDatas topic队列所属的所有broker信息filterServerTable (暂不知道有啥用) 根据topic从topicQueueTable中获取topic下的所有队列,然后遍历队列信息,获取到topic所在的brokerName,然后通过brokerName从brokerAddrTable中获取broker的信息.最后再遍历broker,通过brokerAddr从filterServerTable中获取filterServer的信息 从kvConfig中获取orderTopicConf的信息 这几个作用后面再去梳理 获取到信息后写回到客户端,此时是Response消息,所以客户端执行processResponseCommand方法根据请求的序列号获取到ResponseFuture对象,设置响应码,然后如果有回调函数则调用回调方法,没有就取消阻塞此处getRouteInfoByTopic是同步调用,调用完后调用waitResponse方法阻塞等待返回,要么等待超时时间后抛出异常,要么等待响应结果回来调用putResponse唤醒 最后获取到topicRouteData信息后,与本地之前的数据比较判断是否有更改,如果队列信息或者Broker信息有更改,则会去更新每一个生产者和消费者所持有的队列和broker信息 二、定期发送心跳到namesrvsendHeartbeatToAllBroker客户端有一个定时器定期调用,由heartbeatBrokerInterval控制调用周期,默认为30s,调用代码如下 首先调用prepareHeartbeatData方法生成心跳的信息数据HeartbeatData 心跳信息包括了当前客户端的id、客户端所有的消费者信息、客户端所有的生产者信息如果当前客户端没有任何的消费者和生产者,则直接返回,不用发送心跳 遍历下当前客户端交互的所有broker地址,进行遍历,如果当前客户端无消费者,且broker不是master(brokerId为0的是master),那也不用发送心跳,因为只能往master发送消息,slave只能消费消息然后调用sendHearbeat方法将心跳信息发送给broker,此处也是同步调用,超时时间取的mqClientApiTimeout,默认为3秒 requestCode为HEART_BEAT,值为34 然后通过传入的brokerAddr,与broker建立连接 这个方法可以看出,当addr为空时,就获取或者创建与namesrv的连接,而addr有值时,就获取或者建立与addr的连接然后就是broker端收到请求后的处理,borker端由ClientManageProcessor类负责心跳请求的处理 执行hearbeat方法首先根据心跳信息传过来的客户端消费者信息,判断当前broker是否有订阅组配置对象,如果有,则会调用createTopicInSendMessageBackMethod方法,以%retry%加上消费者组名,新建一个topicConfig对象(不知道创建topic干嘛),如果之前已经创建过则不做处理直接返回,如果没有创建过,则将TopicConfig对象放入topicConfigTable里,并且调用registerBrokerAll通知给所有broker,此处forceRegister默认传的true,代表一定会通知所有broker,如果该值是false的话,方法内部还会调用needRegister方法,请求Namesrv,请求编码是QUERY_DATA_VERSION,值是322(判断是否change,如果change也会去通知所有broker,此处如何判断的change,后续再看) 注册就是将当前broker信息封装成RegisterBrokerRequestHeader对象,请求编码是REGISTER_BROKER,值是103,然后去请求所有的Namesrv,将信息传过去,此处需要所有Namesrv全都请求结束才会接着往下执行 然后接着就是将消费者注册到当前broker 首先判断consumerTable中是否已经存在了,没有就放入.然后基于连接信息判断是否是最新的连接,判断订阅信息是否改变.如果连接是最新的(新加入了消费者)或者订阅信息改变了(新的订阅信息),都代表了消费者有变化了,如果isNotifyConsumerIdsChangedEnable为true的话(默认为true),则会去通知该消费者组的所有消费端去再平衡,后面再调用register方法将订阅信息注册到groupFilterData(这个map不知道干嘛的) 通知客户端再平衡请求编码是NOTIFY_CONSUMER_IDS_CHANGED,值为40,请求体为NotifyConsumerIdsChangedRequestHeader,带有消费者组信息 然后继续看heartBeat方法,后面就是将生产者的连接注册到groupChannelTable中,心跳执行结束,并返回成功给客户端 三、发送消息给broker端客户端请求码SEND_MESSAGE,值为10broker端由SendMessageProcessor进行处理","link":"/2022/01/17/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%A4%84%E7%90%86/"},{"title":"排序算法之快速排序","text":"排序算法之快速排序 算法思想快速排序是一种分治思想,将每切分的那一块都按照标准值分好左右.一直切分直到最后就是一个排序好的数组. 例如数组 第一步,选取第一个值5作为标准值 第二步,然后定义左右指针,左指针从1位置往后遍历,右指针从后往前遍历,最终需要左右指针的左边都是比标准值小,右边比标准值大 第三步,左指针遍历到1位置,获取到值8,比标准值大,则该值应该放在左指针的右边,此时左指针暂停遍历. 第四步,开始遍历右指针,右指针获取到值7,比标准值5大,则继续往前遍历,遍历到下一个值为4,比标准5小.则右指针暂停遍历. 第五步,交换左右指针的值,使得左右指针值都可以满足左边比标准值小,右边比标准值大 第六步: 重复上述1~5步,直到最终左指针大于等于右指针 第七步: 比较相遇位置的值与标准值,为了满足标准值左边的值都比标准值小,右边的值都比标准值大.如果相遇位置值比标准值小,则直接与相遇位置值交换,如果比标准值大,则与相遇前一个位置的值交换.此处由于6是比标准值5大的,所以将5与6的前一个值2进行交换. 此时可以看到数组经过多次交换后,已经形成了左边都比标准值小,右边都比标准值大的局面 第八步: 以标准值为界,将数组切成两份 分别对左右两边执行1~8步,直到最终切分出来的子数组只要1个元素或2个元素,那么直接比较交换. 这样最终得到的就是一个排序的数组 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class PivotSort { public static void main(String[] args) { int[] arr = {5, 8, 3, 6, 2, 4, 7}; pivotSort(arr, 0, arr.length); System.out.println(Arrays.toString(arr)); } public static void pivotSort(int[] nums, int start, int end) { //如果给的数组最多只有1个值,那么直接返回 if (end - start &lt;= 0) { return; //如果是两个值那么直接比较 } else if (end - start == 1) { if (nums[end] &lt; nums[start]) { swap(nums, start, end); } } else { //以起始值为标准值 int pivot = nums[start]; //从第一个值往后遍历 int left = start + 1; //从最后第一个值往前遍历 int right = end; while (left &lt; right) { while (left &lt; end &amp;&amp; nums[left] &lt; pivot) { left++; } while (right &gt; start &amp;&amp; nums[right] &gt;= pivot) { right--; } if (left &lt; right) { swap(nums, left, right); } } int pivotPosition = left; //如果左指针已经在右指针之后了 if (left &gt;= right) { //比较基准值与左指针位置值的大小 if (nums[left] &gt;= pivot) { pivotPosition = left - 1; if (left - 1 != start) { swap(nums, start, left - 1); } } else { swap(nums, start, left); } } //以基准值为界,且成两半,继续执行以上步骤 pivotSort(nums, start, pivotPosition - 1); pivotSort(nums, pivotPosition + 1, end); } } /** * 交换值 * @param nums * @param p1 * @param p2 */ private static void swap(int[] nums, int p1, int p2) { nums[p1] = nums[p1] ^ nums[p2]; nums[p2] = nums[p1] ^ nums[p2]; nums[p1] = nums[p1] ^ nums[p2]; }}","link":"/2021/12/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"rocketmq源码梳理之push模式消费者的建立","text":"rocketmq push消费模式消费者的建立过程 示例代码 //使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); //设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); //设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); //启动消费者消费 consumer.start(); 代码的执行流程1. 消费者对象的初始化//使用消费者组名初始化push模式消费者对象 消费者组名要唯一 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;please_rename_unique_group_name_4&quot;); 进入DefaultMqPushConsumer对象,可以看到声明了很多成员变量并初始化了默认值.整理如下: 变量名 变量类型 变量含义 默认值 messageModel MessageModel 消费消息的模式,有两种配置,集群和广播 集群,MessageModel.CLUSTERING consumeFromWhere ConsumeFromWhere 从何处开始消费,配置值有从最开始、从最新、从指定时间戳 从最新处,ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET; consumeTimestamp String 消费时间戳,yyyyMMddHHmmss格式 当前时间往前推30分钟 consumeThreadMin int 消费线程最小值 20 consumeThreadMax int 消费线程最大值 20 adjustThreadPoolNumsThreshold int 动态调整线程池数量的阈值 10000 consumeConcurrentlyMaxSpan int 并发消费最大数据量 2000 pullThresholdForQueue int 队列缓存的最大消息量 1000 pullThresholdSizeForQueue int 队列拉取的消息的大小阈值,单位为MB 100 pullThresholdForTopic int topic一次性拉取的最大消息量,例如改值设置1000时,而有10个队列的话,则每个队列最大只能拉取100个,相当于pullThresholdForQueue 设置了100 -1,不限制 pullInterval long 拉取间隔 0,拉取后不等待 consumeMessageBatchMaxSize int 消费的批量大小 1 pullBatchSize int 批量拉取大小 32 postSubscriptionWhenPull boolean 拉取的时候是否提交订阅信息 false unitMode boolean 单元模式 false maxReconsumeTimes int 最大重试次数,有序消费时,-1代表无穷大,无序消费时,-1代表16次 -1 suspendCurrentQueueTimeMillis long —- 1000 consumeTimeout long 消费超时时间,单位分钟 15 awaitTerminationMillisWhenShutdown long 停止时暂停等消费时间,0就是不等待 0 同时DefaultMqPushConsumer对象继承了ClientConfig对象,该对象也模式初始化了一些配置,整理如下 变量名 变量类型 变量含义 默认值 namesrvAddr String 元数据服务器地址 从系统参数rocketmq.namesrv.addr中获取,获取不到就从环境变量NAMESRV_ADDR中获取 clientIP String 客户端ip 通过RemotingUtil.getLocalAddress()获取 instanceName String 实例名称 从系统参数rocketmq.client.name中获取,获取不到就使用默认名称DEFAULT clientCallbackExecutorThreads int 客户端回调执行的线程数 通过Runtime.getRuntime().availableProcessors()获取 accessChannel AccessChannel 访问通道,可选值有LOCAL和CLOUD AccessChannel.LOCAL pollNameServerInterval long 从元数据服务器拉取信息间隔 30000,单位毫秒 heartbeatBrokerInterval long 心跳间隔时间 30000,单位毫秒 persistConsumerOffsetInterval long 消费位移持久化间隔 5000,单位毫秒 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 1000,单位毫秒 unitMode boolean 单元模式 false vipChannelEnabled boolean 是否开启vip通道 从系统参数com.rocketmq.sendMessageWithVIPChannel获取,获取不到默认值为false useTLS boolean 是否使用tls安全协议 从系统参数tls.enable获取,获取不到默认值为false mqClientApiTimeout long 客户端超时时间 3000,单位毫秒 language LanguageCode 代码语言 LanguageCode.JAVA 调用了另一个重载的构造方法,并设置了默认的再平衡策略AllocateMessageQueueAveragely 重载的构造方法初始化了DefaultMQPushConsumerImpl对象 DefaultMQPushConsumerImpl对象初始化了设置了pullTimeDelayMillsWhenException,该参数为当出现异常时,拉取消息推迟多少秒,默认值从ClientConfig中获取的,为1000毫秒同时该类也默认初始化了不少配置,整理如下: 变量名 变量类型 变量含义 默认值 pullTimeDelayMillsWhenException long 出现异常后拉取延迟时间 3000,单位毫秒,但是在构造函数执行时,默认会重新赋值,改为ClientConfig中的默认值,为1000 PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL long 出现流量控制后拉取延迟时间 50,单位毫秒 PULL_TIME_DELAY_MILLS_WHEN_SUSPEND long 当消费端暂停后拉取延迟时间 1000,单位毫秒 BROKER_SUSPEND_MAX_TIME_MILLIS long 节点暂停最大时间 15000,单位毫秒 CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND long 当暂停时消费超时时间 30000,单位毫秒 rebalanceImpl RebalanceImpl 再平衡类 RebalancePushImpl,传入了当前对象构造 consumerStartTimestamp long 消费开始时间戳 System.currentTimeMillis(),当前时间 serviceState ServiceState 消费者当前状态,值有CREATE_JUST(创建未启动) 、RUNNING(正在运行)、SHUTDOWN_ALREADY(已经停止)、START_FAILED(启动失败) ServiceState.CREATE_JUST 至此DefaultMQPushConsumer对象初始化完毕,该环节主要是初始化一些配置以及关联对象的一些配置 2. 个性化配置//设置消费起始位置 这里指定的是从头开始消费 consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); 对于一些配置的设置只是改变了下配置值,如上面的设置起始位置,在具体用到的时候会生效.可设置的配置可以关注下上面梳理的各个对象初始化的配置. 3. 配置订阅信息和回调函数//设置订阅的topic 以及tag consumer.subscribe(&quot;TopicTest&quot;, &quot;*&quot;); //设置消费消息后的回调函数 这里使用的不是有序消费 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { System.out.printf(&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread().getName(), msgs); return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); 继续调用了DefaultMQPushConsumerImpl对象的subscribe方法,另外此处通过调用withNamespace方法对topic名称进行包装,就是给topic名称前再加上命名空间的值,如命名空间为aaa,topic为test,此处就会包装成aaa%topic,通过配置命名空间,可以在不改动代码的情况下,切换mq的消费环境 首先使用FilterAPI.buildSubscriptionData(topic, subExpression)生成订阅对象SubscriptionData.该对象保存了订阅的topic,以及配置的过滤表达式,如果指定了tag,将会把tag放入tagSet中,并且将tag的hash值放入codeSet中用以过滤.将subscriptionData放入rebalanceImpl的subscriptionInner成员变量中,这是一个map,key为topic,值为订阅对象此时mQClientFactory对象还未初始化,所以此时还不执行 然后将消费到消息后的回调函数复制给DefaultMQPushConsumer和DefaultMQPushConsumerImpl对象的messageListener对象中 4. 启动消费者//启动消费者消费 consumer.start(); 跟之前的topic一样,给消费者组名加上namespace值然后执行defaultMQPushConsumerImpl的start方法 该方法根据当前服务的状态执行不同的逻辑,由于是刚创建,状态值为CREATE_JUST,所以执行这个分支的逻辑.首先将服务状态修改为START_FAILED再执行后续逻辑,以防止启动异常后重复启动checkConfig检查必要的配置以及配置格式是否正确copySubscription里主要是为当前消费者组增加retry消费者组当消费模式是集群时,调用changeInstanceNameToPID把默认的实例名改为使用进程id 初始化MQClientInstance对象,并以clientId为key,放入factoryTable中.该对象主要用netty与服务端通信 初始化了nettyClientConfig对象,主要配置netty连接的相关配置初始化了ClientRemotingProcessor对象,处理服务端的一些响应逻辑初始化了MQClientAPIImpl,将clientRemotingProcessor的响应逻辑按照响应编码注册到了netty中初始化了MQAdminImpl对象初始化了PullMessageService对象初始化了RebalanceService对象初始化了defaultMQProducer对象初始化了consumerStatsManager对象,可打印状态信息 紧接着主线的初始化给自平衡对象设置消费者组名,消费模式,再平衡策略,以及通信客户端 紧接着初始化了PullAPIWrapper对象紧接着初始化了OffsetStore对象,当下消费模式为集群模式,所以使用了RemoteBrokerOffsetStore. 紧接着根据回调函数类型,来设置消费是否有序,当下为无序消费,ConsumeMessageConcurrentlyService,调用该类的start方法,会启动一个定期执行的线程池,用以清理过期消息 以consumerGroup为key,当前消费者对象为值放入MQClientInstance的consumerTable中 然后调用MQClientInstance的start方法 首先获取元数据服务器地址然后调用mqClientApiImpl的start方法与mq服务端建立netty连接然后启动部分定时任务然后启动拉取线程然后启动再平衡线程然后启动默认的producer线程然后修改服务状态为Running至此初始化结束. 后面都是各个线程执行操作.核心就是以下几个线程 RebalanceService定期再平衡PullMessageService定期拉取数据fetchNameServerAddr定期获取元数据地址updateTopicRouteInfoFromNameServer定期获取topic路由cleanOfflineBroker定期清理下线节点sendHeartbeatToAllBrokerWithLock定期发送心跳线程persistAllConsumerOffset持久化所有消费位移adjustThreadPool定期调整线程池 下面重点介绍这些线程的作用 各线程作用RebalanceService 等待间隔waitInterval,取自系统参数rocketmq.client.rebalance.waitInterval,如果未设置,默认值为20ms 如果hasNotified为true,则不等待直接返回否则等待interval时间再返回 遍历consumerTable,执行每一个消费者对象的doRebalance方法,当前为Push模式的消费者,所以执行DefaultMQPushConsumerImpl的doRebalance方法 最终调用的RebalanceImpl的doRebalance方法,当前是无序 获取订阅信息,根据订阅信息获取topic,然后调用rebalanceByTopic方法,该方法根据消费模式执行不同的再平衡逻辑,当前消费模式是集群 获取当前topic的队列信息获取当前消费者组的各个消费者id根据再平衡策略将队列分配给各个消费者组,当前默认分配策略是平均分配 算法如下:假如有11个队列,4个消费者,平分的话每个消费者能分两个,余数为3.余数的3个再根据消费者顺序按顺序分配给前3个消费者.这样4个消费者分配方案就是3332 给当前消费者分配好消费队列后,与之前分配的队列进行比较.如果之前分配的队列不在新的分配队列里了,则将其移除如果是新添加的队列,则根据消费模式去获取消费的位移,根据配置的消费起始,去计算位移.例如当前配置的是从最开始处获取位移 先从本地获取位移,本地有位移以本地为主,本地要是没位移则如果刚开始新建设置为-1,如果已经设置了-1则从0开始消费 如果位移是大于等于0的,则新建一个PullRequest对象以当前位移开始去拉数据. 如果产生了队列的变化,则执行messageQueueChanged方法通知给服务端根据当前时间戳更新队列的版本号,根据当前队列数量计算pullThresholdForTopic和pullThresholdSizeForTopic然后通过发送心跳包将订阅信息更新给服务端.至此再平衡结束 PullMessageService 从pullRequestQueue中获取pullRequest对象,然后去拉取消息 判断当前ProcessQueue是否还是该消费者消费,如果不是直接返回判断当前消费对象是否是暂停状态,如果是延迟放入队列直接返回根据当前ProcessQueue缓存的消息数量和消息大小判断是否超过了配置的大小,超过则进行流控延迟放入队列直接返回判断当前ProcessQueue的跨度是否超过配置值,超过也进行流控延迟放入队列直接返回获取订阅信息,如果订阅信息为空延迟放入队列直接返回初始化回调函数,用于处理消费到的消息,具体消费逻辑后续再说使用netty客户端拉取消息 可以看到将调用信息封装成了一个ResponseFuture对象,并且在netty调用回调里调用成功和失败通过ResponseFuture执行了不同的逻辑. 在netty客户端对象NettyRemotingClient初始化的时候,也有初始化了一个定时线程 该线程会每秒执行一次,获取ResponseFuture对象,判断消息超时后会同样调用回调逻辑. 此处再看回调函数里的处理 当有响应结果才会去调用Onsuccess方法,其他都是调用OnException 当OnSuccess时会根据获取的响应结果的状态执行不同的逻辑当是Found时,即是拉取到了消息,首先获取下次拉取消息的开始位移,留待后续拉取,然后将拉取到的消息调用consumeMessageService.submitConsumeRequest进行处理,目前消费方式不是有序,使用的是ConsumeMessageConcurrentlyService对象,该方法内部会将拉取到的消息封装成ConsumeRequest对象,该对象是个线程,然后内部处理会调用一开始初始化Consumer对象传入的lisener的cousumerMessage方法进行处理当是NO_NEW_MSG和NO_MATCHED_MSG时,即本次没拉取到消息,则立即再次拉取当时OFFSET_ILLEGAL时,即位移是不合法的,则移除当前的ProcessQueue,当再平衡时会重新分配,重新分配的时候会重新获取最新位移 当OnException时,会打印对应的异常信息,并延迟放入队列等待重新拉取 fetchNameServerAddr定期获取NameServer线程如果NameServer是空,该线程会定期访问配置的接口获取nameserver信息 可以做到在运行过程中切换mq环境 updateTopicRouteInfoFromNameServer定期根据当前消费者所订阅的topic从NameServer中获取元数据信息,包括broker节点信息,队列信息等 cleanOfflineBroker定期清理下线节点 sendHeartbeatToAllBrokerWithLock定期与节点发送心跳信息,将当前消费者的信息发送给broker端 persistAllConsumerOffset定期持久化消费位移到内存offsetStore对象里 adjustThreadPool定期调整线程池大小 内存dump里需要关注的对象MqClientInstance与mq服务端交互的客户端对象,以instanceName确定唯一,每个instanceName会单独建立一个对象 DefaultMQPushConsumerImplpush消费具体处理逻辑的对象,包括调用再平衡,请求消息,处理消息等等 OffsetStore集群模式消费的位移存在RemoteOffsetStore中,在拉取消息的时候会先从服务端同步位移,同步不到位移的时候才会从头开始消费","link":"/2022/01/06/rocketmq%E6%BA%90%E7%A0%81%E6%A2%B3%E7%90%86%E4%B9%8Bpush%E6%A8%A1%E5%BC%8F%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%BB%BA%E7%AB%8B/"}],"tags":[{"name":"源码","slug":"源码","link":"/tags/%E6%BA%90%E7%A0%81/"},{"name":"juc","slug":"juc","link":"/tags/juc/"},{"name":"lock","slug":"lock","link":"/tags/lock/"},{"name":"java基础","slug":"java基础","link":"/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"rocketmq","slug":"rocketmq","link":"/tags/rocketmq/"},{"name":"jvmagent","slug":"jvmagent","link":"/tags/jvmagent/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"源码","slug":"源码","link":"/categories/%E6%BA%90%E7%A0%81/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}